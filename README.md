# `whatsapp-shell`

```bash
$ python wshell.py
```
## Todo
- [x] Finish the `NOISE_XX_AES_128` handshake
  - [x] Reverse the `.proto` file for the structure of the protobuf
  
        This was easy enough in the Debugger where the structure can be viewed quite easily.
        Will put up an image detailing it soon. Possibly make an extract script from it as well.
	- [x] Finish decrypting the shello.static and shello.payload blobs	
	- [x] Construct the client finish message
- [x] Get the QR
	- [x] Decrypt the server response on Noise Handshake successful
	- [x] Extract the correct `ref` string from the decrypted parsed data
	- [x] Construct the QR code
	- [x] Scan and test
  
            Scanning shows an error msg saying that device could not be linked now. However,
            our client gets partially linked as it throws a max linking error after ~5 tries.
            Need to figure out why linking fails.
	- [x] Write a `WapParser` (Line #11128)
	- [x] Write a WapEncoder (Line #10727)
	- [x] A 37 byte frame is sent to the server. ~~what is it ?~~ -- possibly called the `result`
	- [x] A ~250 byte response is sent from the server which I don't get yet. Get that msg
	- [ ] Repair the parser `Y`
- [ ] Refactor `wap.py`
- [ ] Refactor `wshell.py`
- [ ] Replicate `libsignal-protocol`'s signing algo and see how it is diff from `DJM`
- [ ] Retrieve Messages


## Notes
1. The signature generation problem appears to be one reagrding the incompatibility of Ed25519
and XEd25519 signatures. In a nutshell, it appears that signatures generated by XEd25519 keys
*(which are also equivalent to X25519 keys)* are required for verification. When I generated sigs
using the `Ed25519` routines from the `cryptography/ed25519` library, they cannot be verified.
**Reference** - https://crypto.stackexchange.com/questions/62879/verifying-eddsa-signatures-using-xeddsa-verify-function

2. The Signal docs also mention this signature scheme.
**Reference** - https://signal.org/docs/specifications/xeddsa/

3. For now, I'm generating keys using `X25519()` and signing using a python binding for the `libsignal` lib.
4. Also take a look at whether the XEd25519 spec allows for randomisation. **(it was not there in the ed25519
signature algo)**
